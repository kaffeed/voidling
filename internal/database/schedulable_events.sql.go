// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: schedulable_events.sql

package database

import (
	"context"
	"database/sql"
	"time"
)

const createSchedulableEvent = `-- name: CreateSchedulableEvent :one
INSERT INTO schedulable_events (type, activity, location, scheduled_at, discord_event_id, timezone)
VALUES (?, ?, ?, ?, ?, ?)
RETURNING id, type, activity, location, scheduled_at, created_at, discord_event_id, timezone
`

type CreateSchedulableEventParams struct {
	Type           string         `json:"type"`
	Activity       string         `json:"activity"`
	Location       string         `json:"location"`
	ScheduledAt    time.Time      `json:"scheduled_at"`
	DiscordEventID string         `json:"discord_event_id"`
	Timezone       sql.NullString `json:"timezone"`
}

func (q *Queries) CreateSchedulableEvent(ctx context.Context, arg CreateSchedulableEventParams) (SchedulableEvent, error) {
	row := q.db.QueryRowContext(ctx, createSchedulableEvent,
		arg.Type,
		arg.Activity,
		arg.Location,
		arg.ScheduledAt,
		arg.DiscordEventID,
		arg.Timezone,
	)
	var i SchedulableEvent
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.Activity,
		&i.Location,
		&i.ScheduledAt,
		&i.CreatedAt,
		&i.DiscordEventID,
		&i.Timezone,
	)
	return i, err
}

const createSchedulableParticipation = `-- name: CreateSchedulableParticipation :one
INSERT INTO schedulable_event_participations (event_id, account_link_id, notified)
VALUES (?, ?, ?)
RETURNING id, event_id, account_link_id, notified, created_at
`

type CreateSchedulableParticipationParams struct {
	EventID       int64 `json:"event_id"`
	AccountLinkID int64 `json:"account_link_id"`
	Notified      bool  `json:"notified"`
}

func (q *Queries) CreateSchedulableParticipation(ctx context.Context, arg CreateSchedulableParticipationParams) (SchedulableEventParticipation, error) {
	row := q.db.QueryRowContext(ctx, createSchedulableParticipation, arg.EventID, arg.AccountLinkID, arg.Notified)
	var i SchedulableEventParticipation
	err := row.Scan(
		&i.ID,
		&i.EventID,
		&i.AccountLinkID,
		&i.Notified,
		&i.CreatedAt,
	)
	return i, err
}

const deleteSchedulableEvent = `-- name: DeleteSchedulableEvent :exec
DELETE FROM schedulable_events
WHERE id = ?
`

func (q *Queries) DeleteSchedulableEvent(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteSchedulableEvent, id)
	return err
}

const getSchedulableEventByID = `-- name: GetSchedulableEventByID :one
SELECT id, type, activity, location, scheduled_at, created_at, discord_event_id, timezone FROM schedulable_events
WHERE id = ?
LIMIT 1
`

func (q *Queries) GetSchedulableEventByID(ctx context.Context, id int64) (SchedulableEvent, error) {
	row := q.db.QueryRowContext(ctx, getSchedulableEventByID, id)
	var i SchedulableEvent
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.Activity,
		&i.Location,
		&i.ScheduledAt,
		&i.CreatedAt,
		&i.DiscordEventID,
		&i.Timezone,
	)
	return i, err
}

const getSchedulableEvents = `-- name: GetSchedulableEvents :many
SELECT id, type, activity, location, scheduled_at, created_at, discord_event_id, timezone FROM schedulable_events
ORDER BY scheduled_at DESC
`

func (q *Queries) GetSchedulableEvents(ctx context.Context) ([]SchedulableEvent, error) {
	rows, err := q.db.QueryContext(ctx, getSchedulableEvents)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SchedulableEvent{}
	for rows.Next() {
		var i SchedulableEvent
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.Activity,
			&i.Location,
			&i.ScheduledAt,
			&i.CreatedAt,
			&i.DiscordEventID,
			&i.Timezone,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSchedulableEventsInTimeRange = `-- name: GetSchedulableEventsInTimeRange :many
SELECT id, type, activity, location, scheduled_at, created_at, discord_event_id, timezone FROM schedulable_events
WHERE scheduled_at >= ? AND scheduled_at < ?
ORDER BY scheduled_at ASC
`

type GetSchedulableEventsInTimeRangeParams struct {
	ScheduledAt   time.Time `json:"scheduled_at"`
	ScheduledAt_2 time.Time `json:"scheduled_at_2"`
}

func (q *Queries) GetSchedulableEventsInTimeRange(ctx context.Context, arg GetSchedulableEventsInTimeRangeParams) ([]SchedulableEvent, error) {
	rows, err := q.db.QueryContext(ctx, getSchedulableEventsInTimeRange, arg.ScheduledAt, arg.ScheduledAt_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SchedulableEvent{}
	for rows.Next() {
		var i SchedulableEvent
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.Activity,
			&i.Location,
			&i.ScheduledAt,
			&i.CreatedAt,
			&i.DiscordEventID,
			&i.Timezone,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSchedulableParticipation = `-- name: GetSchedulableParticipation :one
SELECT id, event_id, account_link_id, notified, created_at FROM schedulable_event_participations
WHERE event_id = ? AND account_link_id = ?
LIMIT 1
`

type GetSchedulableParticipationParams struct {
	EventID       int64 `json:"event_id"`
	AccountLinkID int64 `json:"account_link_id"`
}

func (q *Queries) GetSchedulableParticipation(ctx context.Context, arg GetSchedulableParticipationParams) (SchedulableEventParticipation, error) {
	row := q.db.QueryRowContext(ctx, getSchedulableParticipation, arg.EventID, arg.AccountLinkID)
	var i SchedulableEventParticipation
	err := row.Scan(
		&i.ID,
		&i.EventID,
		&i.AccountLinkID,
		&i.Notified,
		&i.CreatedAt,
	)
	return i, err
}

const getSchedulableParticipationsByEvent = `-- name: GetSchedulableParticipationsByEvent :many
SELECT sep.id, sep.event_id, sep.account_link_id, sep.notified, sep.created_at, al.discord_member_id, al.runescape_name
FROM schedulable_event_participations sep
JOIN account_links al ON sep.account_link_id = al.id
WHERE sep.event_id = ?
ORDER BY sep.created_at
`

type GetSchedulableParticipationsByEventRow struct {
	ID              int64     `json:"id"`
	EventID         int64     `json:"event_id"`
	AccountLinkID   int64     `json:"account_link_id"`
	Notified        bool      `json:"notified"`
	CreatedAt       time.Time `json:"created_at"`
	DiscordMemberID int64     `json:"discord_member_id"`
	RunescapeName   string    `json:"runescape_name"`
}

func (q *Queries) GetSchedulableParticipationsByEvent(ctx context.Context, eventID int64) ([]GetSchedulableParticipationsByEventRow, error) {
	rows, err := q.db.QueryContext(ctx, getSchedulableParticipationsByEvent, eventID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetSchedulableParticipationsByEventRow{}
	for rows.Next() {
		var i GetSchedulableParticipationsByEventRow
		if err := rows.Scan(
			&i.ID,
			&i.EventID,
			&i.AccountLinkID,
			&i.Notified,
			&i.CreatedAt,
			&i.DiscordMemberID,
			&i.RunescapeName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUnnotifiedParticipations = `-- name: GetUnnotifiedParticipations :many
SELECT sep.id, sep.event_id, sep.account_link_id, sep.notified, sep.created_at, al.discord_member_id, al.runescape_name, se.activity, se.location, se.scheduled_at, se.type
FROM schedulable_event_participations sep
JOIN account_links al ON sep.account_link_id = al.id
JOIN schedulable_events se ON sep.event_id = se.id
WHERE sep.notified = 0 AND se.scheduled_at >= ? AND se.scheduled_at < ?
ORDER BY se.scheduled_at ASC
`

type GetUnnotifiedParticipationsParams struct {
	ScheduledAt   time.Time `json:"scheduled_at"`
	ScheduledAt_2 time.Time `json:"scheduled_at_2"`
}

type GetUnnotifiedParticipationsRow struct {
	ID              int64     `json:"id"`
	EventID         int64     `json:"event_id"`
	AccountLinkID   int64     `json:"account_link_id"`
	Notified        bool      `json:"notified"`
	CreatedAt       time.Time `json:"created_at"`
	DiscordMemberID int64     `json:"discord_member_id"`
	RunescapeName   string    `json:"runescape_name"`
	Activity        string    `json:"activity"`
	Location        string    `json:"location"`
	ScheduledAt     time.Time `json:"scheduled_at"`
	Type            string    `json:"type"`
}

func (q *Queries) GetUnnotifiedParticipations(ctx context.Context, arg GetUnnotifiedParticipationsParams) ([]GetUnnotifiedParticipationsRow, error) {
	rows, err := q.db.QueryContext(ctx, getUnnotifiedParticipations, arg.ScheduledAt, arg.ScheduledAt_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUnnotifiedParticipationsRow{}
	for rows.Next() {
		var i GetUnnotifiedParticipationsRow
		if err := rows.Scan(
			&i.ID,
			&i.EventID,
			&i.AccountLinkID,
			&i.Notified,
			&i.CreatedAt,
			&i.DiscordMemberID,
			&i.RunescapeName,
			&i.Activity,
			&i.Location,
			&i.ScheduledAt,
			&i.Type,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUpcomingSchedulableEvents = `-- name: GetUpcomingSchedulableEvents :many
SELECT id, type, activity, location, scheduled_at, created_at, discord_event_id, timezone FROM schedulable_events
WHERE scheduled_at > ?
ORDER BY scheduled_at ASC
`

func (q *Queries) GetUpcomingSchedulableEvents(ctx context.Context, scheduledAt time.Time) ([]SchedulableEvent, error) {
	rows, err := q.db.QueryContext(ctx, getUpcomingSchedulableEvents, scheduledAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SchedulableEvent{}
	for rows.Next() {
		var i SchedulableEvent
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.Activity,
			&i.Location,
			&i.ScheduledAt,
			&i.CreatedAt,
			&i.DiscordEventID,
			&i.Timezone,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markParticipationAsNotified = `-- name: MarkParticipationAsNotified :exec
UPDATE schedulable_event_participations
SET notified = 1
WHERE id = ?
`

func (q *Queries) MarkParticipationAsNotified(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, markParticipationAsNotified, id)
	return err
}
